{"name":"The Monad Challenges","tagline":"A set of challenges for jump starting your understanding of monads.","body":"# The Monad Challenges\r\n\r\n## Welcome\r\n\r\nThe guys who wrote the [matasano crypto challenges](http://cryptopals.com/)\r\nrealized that you cannot get a working knowledge of crypto without investing\r\nblood, sweat, and tears into playing with and attempting to break crypto.\r\nThey even say, \"But more people 'know how' to break it than can actually break\r\nit.\"  Their crypto challenges provide a structured way for people to make the\r\nrequisite blood, sweat, and tears investment to get to a place of\r\nunderstanding.\r\n\r\nWe believe the same is true when learning monads.  Monads cannot be taught.\r\nThey must be _discovered_.  The problem with monad tutorials is that they are\r\npredicated on someone teaching/explaining monads.  But you must explore them\r\nyourself.  You will never really understand monads until you do this.  The\r\nproblem is that beginners do not usually know how to explore.  We put together\r\nthis set of challenges to show you how to do that.\r\n\r\n_Please do NOT publish the answers to these challenges._  Reading answers that\r\nyou did not create yourself defeats the whole purpose.\r\n\r\n### Do I need to know category theory?\r\n\r\nNo.\r\n\r\n### Do I need to know Haskell?\r\n\r\nYes, we assume that you have some beginner \"pre-monad\" level knowledge of\r\nthe following Haskell concepts:\r\n\r\n* Basic syntax\r\n* Type signatures\r\n* Higher order functions\r\n* Type aliases\r\n* newtypes\r\n* Polymorphism\r\n* Type classes\r\n\r\nWe are not trying to teach you Haskell here. We are trying to guide you down the\r\npath to a fully internalized working knowledge of monads. If you need to learn\r\nHaskell, go work through some beginning Haskell materials and come back when you\r\nthink you need to learn monads.\r\n\r\n### Organizing Your Code\r\n\r\nIt will probably help if you organize your code into one file per set of\r\nchallenges.  Some of the problem sets build on previous ones, so it will be\r\nconvenient to be able to easily import your code for a whole set or find it\r\nfor reference.\r\n\r\n### Who did this?\r\n\r\n* Doug Beardsley (with feedback and suggestions from Brent Yorgey)\r\n\r\n### Code Template\r\n\r\nFor all of these problem sets you should use the following language pragmas\r\nand imports:\r\n\r\n    {-# LANGUAGE MonadComprehensions #-}\r\n    {-# LANGUAGE RebindableSyntax  #-}\r\n\r\n    module Set1 where\r\n\r\n    import MCPrelude\r\n\r\nMCPrelude should be the only module you import.  Do not import any other\r\nmodules.  We are giving you a special prelude because we want you to solve\r\nthese challenges without the use of monad libraries that have already done the\r\nwork for you.  Also, don't look at the code in Control.Monad, the transformers\r\npackage, or the mtl package.  You're doing this to learn.  To do that you need\r\nto struggle with the concepts.  Don't cheat yourself out of the benefit you\r\ncan get by working through things yourself.\r\n\r\n## Outline\r\n\r\n* [Set 1: Random Number Generation](set1.md)\r\n* [Set 2: Failing Computations](set2.md)\r\n* [Set 3: Generating Permutations](set3.md)\r\n* [Set 4: Finding the Common Thread](set3.md)","google":"UA-72594732-1","note":"Don't delete this file! It's used internally to help with page regeneration."}